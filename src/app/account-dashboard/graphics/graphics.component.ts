import { Component, OnInit, ViewChild } from '@angular/core';
import { ChartDataSets, ChartOptions, ChartPoint } from 'chart.js';
import * as pluginAnnotations from 'chartjs-plugin-annotation';
import { BaseChartDirective, Color, Label } from 'ng2-charts';
import { first } from 'rxjs/operators';
import { ErrorMessageService } from 'src/app/error-messages/error-messageService';
import { HTTPSRequestService } from 'src/app/Server-HTTPS/IHTTPS-Request';
import { TrimType, New, NewTasks, NewData } from 'src/app/_GlobalValues/global-values';
import { DocumentAndTask, GraphMetaData, GraphTasksAvaliable, OrganisedGraphData, OrganisedDocumentTasks, OrganisedTaskData, RequestGraphData, ServerData, TaskData } from "src/app/_GlobalValues/httpObjectInterfaces";

//TODO will need to fix error i think. doesn't display
/**
 * Will need a different screen that has all the avaliable bit of data to choose from for graphing,
 * This then switchs over to the graph and gets that data
 * Bonus feature to get more data without having to go back and generate new graph?
 */

@Component({
  selector: 'app-graphics',
  templateUrl: './graphics.component.html',
  styleUrls: ['./graphics.component.css']
})
export class GraphicsComponent implements OnInit {
  documents: GraphTasksAvaliable;
  retrievedTasks: Array<string> = new Array<string>();
  GraphData: Array<OrganisedGraphData> = new Array<OrganisedGraphData>();
  dataBeingDisplayed: Boolean;
  graphMetaData: GraphMetaData;
  allDatesSelected: Boolean;
  numberofCallBacksLeft: number;
  //TODO will need a ENUM to dictate how the retrieved task data is handled

  //TODO here will need to link the colors into another option maybe? so they can be changed
  public lineChartData: ChartDataSets[];
  /**
 *     //Get data here
    this.lineChartData = [
      { data: [65, 59, 80, 81, 56, 55, 40], label: 'Series A' },
      { data: [28, 48, 40, 19, 86, 27, 90], label: 'Series B' },
      { data: [180, 480, 770, 90, 1000, 270, 400], label: 'Series C', yAxisID: 'y-axis-1' }
    ];
  }
   */
  public lineChartLabels: Label[];
  public lineChartOptions: (ChartOptions) = {
    responsive: true,
    scales: {
      // We use this empty structure as a placeholder for dynamic theming.
      yAxes: [
        {
          ticks: {
            beginAtZero: true
          }
        }
      ],
      xAxes: [{
        type: 'time',
        distribution: 'series',
        time: {
          displayFormats: {//TODO add a option to allow user to change format
            'millisecond': 'h:mma DD/MM/YYYY',
            'second': 'h:mma DD/MM/YYYY',
            'minute': 'h:mma DD/MM/YYYY',
            'hour': 'h:mma DD/MM/YYYY',
            'day': 'h:mma DD/MM/YYYY',
            'week': 'h:mma DD/MM/YYYY',
            'month': 'h:mma DD/MM/YYYY',
            'quarter': 'h:mma DD/MM/YYYY',
            'year': 'h:mma DD/MM/YYYY',
          }
        }
      }]
    },
  };
  public lineChartColors: Color[] = [
    { // grey
      backgroundColor: 'rgba(148,159,177,0.2)',
      borderColor: 'rgba(148,159,177,1)',
      pointBackgroundColor: 'rgba(148,159,177,1)',
      pointBorderColor: '#fff',
      pointHoverBackgroundColor: '#fff',
      pointHoverBorderColor: 'rgba(148,159,177,0.8)'
    },
    { // red
      backgroundColor: 'rgba(255,0,0,0.3)',
      borderColor: 'red',
      pointBackgroundColor: 'rgba(148,159,177,1)',
      pointBorderColor: '#fff',
      pointHoverBackgroundColor: '#fff',
      pointHoverBorderColor: 'rgba(148,159,177,0.8)'
    }
  ];
  public lineChartLegend = true;
  public lineChartType = 'line';
  public lineChartPlugins = [pluginAnnotations];

  @ViewChild(BaseChartDirective, { static: true }) chart: BaseChartDirective;

  constructor(private HTTPSService: HTTPSRequestService,
    private errorService: ErrorMessageService) { }// Generated by https://quicktype.io

  ngOnInit() {
    this.numberofCallBacksLeft = 0;
    this.allDatesSelected = false;
    this.dataBeingDisplayed = false;
    //this.graphMetaData.EndDateDisplayed = null;
    //this.graphMetaData.StartDateDisplayed = null;
    this.HTTPSService.GetDocumentsForGraph().pipe(first())
      .subscribe((data: GraphTasksAvaliable) => {
        this.documents = data;
      },
        error => {
          this.errorService.error(error);
        });
    this.lineChartData = [{ data: [] }];
  }

  //TODO future requirement will send an array of start/end dates so that only 1 call is made to the backend when expanding each side at the same time
  //Keep this 'smart' not requesting duplicate data, unless going from between to all, as it makes it simpler
  //TODO break this up, alot of repeated code in sections. move that code to functions! 
  getData() {
    //TODO lock the getData button until all has been completed, including data returned and graphed!!!
    let requests: Array<RequestGraphData> = new Array<RequestGraphData>();
    let requestData: RequestGraphData = new RequestGraphData();
    //Will need to check what has changed and get that new data. Will need to check if
    //date has been changed. If changed get all the new data for each part as well
    //If all, remove all current data and get entire set new,
    let startDateValue: string = (<HTMLInputElement> document.getElementById("startDate")).value;
    let endDateValue: string = (<HTMLInputElement> document.getElementById("endDate")).value;
    let allDatesValue: boolean = (<HTMLInputElement> document.getElementById("AllDates")).checked;
    let tasksSelected: Array<DocumentAndTask> = this.GetAllTasksUUIDSelected();
    if (!this.ValidDateSelectedForGraph(startDateValue, endDateValue, allDatesValue) || tasksSelected == null) {
      console.log('Error');
      //TODO ERROR MESSAGE invalid selection please try again
      return;
    }
    console.log('Valid Selection');
    //check if first time for data, if so can skip all the logic below and get what is needed
    if (!this.dataBeingDisplayed) {
      console.log('no data displayed, getting new data');
      this.dataBeingDisplayed = true;
      requestData.DataType = New;
      requestData.DocumentAndTasks = tasksSelected;
      if (allDatesValue) {
        this.allDatesSelected = true;
        console.log('All Values wanted');
        requestData.StartDate = "None";
        requestData.EndDate = "None";
      } else {
        console.log('specific dates selected: Start=' + startDateValue + ', End=' + endDateValue);
        requestData.StartDate = this.StringConvertFrontEndDateToServer(startDateValue);
        requestData.EndDate = this.StringConvertFrontEndDateToServer(endDateValue);
      }
      console.log('Created requestData');
      requests.push(requestData);
    }
    //If going from all dates to specified dates, then can see what information already exists for avaliable tasks -> reduce the request load on server
    else if (this.allDatesSelected && !allDatesValue) {
      this.allDatesSelected = false;
      this.trimData(new Date(startDateValue), new Date(endDateValue));
      return;
    }
    //check if any dates have been extended
    //If a select all dates is used check if need to clear and get all new, or just get all for new task UUIDs selected
    else if (this.dataBeingDisplayed && allDatesValue) {
      console.log('Tasks selected and AllDates previously Checked');
      if (this.allDatesSelected) {//filter task UUIDs for only new ones selected
        console.log('New Tasks selected Filter');
        requestData.DataType = NewTasks;
        let newTaskUUIDS = this.filterTasks(tasksSelected);
        console.log('Return from filter tasks length ' + newTaskUUIDS.length);
        if (newTaskUUIDS.length) {
          console.log('newTaskUUIDS: ' + JSON.stringify(newTaskUUIDS));
          requestData.DocumentAndTasks = newTaskUUIDS;
        } else {
          this.removeUncheckedDocumentsAndTasks(tasksSelected);
          return;
        }
      } else {//Get everything required as otherwise will be very very messy. 
        console.log('Getting all Task data, due to going from specific dates and all');
        requestData.DataType = New;
        this.allDatesSelected = true;
        requestData.DocumentAndTasks = tasksSelected;
      }
      requestData.StartDate = "None";
      requestData.EndDate = "None";
      requests.push(requestData);
    }
    //Last check will be if increasing/decreasing date sets ->specific functionality for each scenario
    /**
     * Will need to determine new UUIDs, and distiguish ones with current data. This will result in multiple requests for data,
     * But will reduce the amount of data required. Future development maybe worth looking at modifying date requirements so only
     * 1 request is made for new data on existing Tasks graphed.
     * Not sure how you would have new tasks requested in the same https call. Is probably best to keep that in a seperate https request
     * for simplicity.
     * */
    //If expand date start and end currently send 2 http requests to server
    else {
      let newTaskUUIDS = this.filterTasks(tasksSelected);
      if (newTaskUUIDS.length) {//Send off request for these new tasks
        let newTasksRequest: RequestGraphData = new RequestGraphData();
        newTasksRequest.DocumentAndTasks = newTaskUUIDS;
        newTasksRequest.DataType = NewTasks;
        newTasksRequest.StartDate = this.StringConvertFrontEndDateToServer(startDateValue);
        newTasksRequest.EndDate = this.StringConvertFrontEndDateToServer(endDateValue);
        requests.push(newTasksRequest);
      } else {
        this.removeUncheckedDocumentsAndTasks(tasksSelected);
      }
      //Now check how the dates where modified. This will either cause 2 http requests, one for lower date and upper date
      //Or could result in 1 or 0. 0 if dates are now inbetween current dates displayed so just reduce the data stored to be shown
      let newStartDate = new Date(startDateValue);
      let newEndDate = new Date(endDateValue);
      //Check how new date are compared to current
      //If need new sections, add 1 day to larger and minus for smaller current cutoffs so no repeats
      //2 calls for new data
      if (newStartDate < this.graphMetaData.StartDateDisplayed && newEndDate > this.graphMetaData.EndDateDisplayed) {
        //get list of current UUIDS
        let newStartDateDataSectionRequest: RequestGraphData = new RequestGraphData();
        let newhigherstartDate: Date;
        newStartDateDataSectionRequest.DataType = NewData;
        newhigherstartDate.setDate(this.graphMetaData.StartDateDisplayed.getDate() - 1);
        newStartDateDataSectionRequest.StartDate = this.DateConvertFrontEndDateToServer(newStartDate);
        newStartDateDataSectionRequest.EndDate = this.DateConvertFrontEndDateToServer(newhigherstartDate);
        let EndDateDataSectionRequest: RequestGraphData = new RequestGraphData();
        let newEndDateStart: Date;
        EndDateDataSectionRequest.DataType = NewData;
        newEndDateStart.setDate(this.graphMetaData.EndDateDisplayed.getDate() + 1);
        EndDateDataSectionRequest.StartDate = this.DateConvertFrontEndDateToServer(newEndDateStart);
        EndDateDataSectionRequest.EndDate = this.DateConvertFrontEndDateToServer(newEndDateStart);
        let requestedDocuments = this.getCurrentTaskUUIDS();
        newStartDateDataSectionRequest.DocumentAndTasks = requestedDocuments;
        EndDateDataSectionRequest.DocumentAndTasks = requestedDocuments;
        requests.push(newStartDateDataSectionRequest);
        requests.push(EndDateDataSectionRequest);
        //
      } else if (newStartDate >= this.graphMetaData.StartDateDisplayed && newEndDate > this.graphMetaData.EndDateDisplayed) {//1 call for enddate, and trim start date
        //TrimStartDateData
        this.trimData(new Date(startDateValue), null);
        //Get New EnddateData
        let EndDateDataSectionRequest: RequestGraphData = new RequestGraphData();
        let newEndDateStart: Date;
        EndDateDataSectionRequest.DataType = NewData;
        newEndDateStart.setDate(this.graphMetaData.EndDateDisplayed.getDate() + 1);
        EndDateDataSectionRequest.StartDate = this.DateConvertFrontEndDateToServer(newEndDate);
        EndDateDataSectionRequest.EndDate = this.DateConvertFrontEndDateToServer(newEndDateStart);
        EndDateDataSectionRequest.DocumentAndTasks = this.getCurrentTaskUUIDS();
        requests.push(EndDateDataSectionRequest);
      } else if (newStartDate < this.graphMetaData.StartDateDisplayed && newEndDate <= this.graphMetaData.EndDateDisplayed) {//1 call for startdate and trim
        this.trimData(null, new Date(endDateValue));
        //Get New StartdateData
        let newStartDateDataSectionRequest: RequestGraphData = new RequestGraphData();
        let newhigherstartDate: Date;
        newStartDateDataSectionRequest.DataType = NewData;
        newhigherstartDate.setDate(this.graphMetaData.StartDateDisplayed.getDate() - 1);
        newStartDateDataSectionRequest.StartDate = this.DateConvertFrontEndDateToServer(newStartDate);
        newStartDateDataSectionRequest.EndDate = this.DateConvertFrontEndDateToServer(newhigherstartDate);
        newStartDateDataSectionRequest.DocumentAndTasks = this.getCurrentTaskUUIDS();
        requests.push(newStartDateDataSectionRequest);
      } else if (newStartDate < this.graphMetaData.StartDateDisplayed && newEndDate > this.graphMetaData.EndDateDisplayed) {//Just need to reduce what is been shown
        this.trimData(new Date(startDateValue), new Date(newEndDate));
      }
    }
    this.numberofCallBacksLeft = requests.length;
    for (let HTTPSRequest of requests) {
      this.HTTPSCallForGraphData(HTTPSRequest);
    }
  }
  removeUncheckedDocumentsAndTasks(tasksSelected: DocumentAndTask[]) {
    //Create 2 new arrays, 1 of DocumentUUIDs and 1 of TaskUUIDs, this can then be used to filter against current meta data to get the
    //UUIDS required to be removed. These arrays can then be set as the new meta data
    let newDocumentUUIDsMetaData = new Array<string>();
    let newTaskUUIDsMetaData = new Array<string>();
    //Documents will be abit harder to remove
    //Check the difference between tasksSelected and metadata
    //loop through tasksSelected and then 
    for (let Document of tasksSelected) {
      newDocumentUUIDsMetaData.push(Document.DocumentUUID);
      newTaskUUIDsMetaData.concat(Document.TaskUUIDs.split(','));
    }
    //Now get the removed UUIDS
    let DocumentUUIDsToRemove = this.graphMetaData.DocumentUUIDS.filter(DocumentUUID => {
      !newDocumentUUIDsMetaData.includes(DocumentUUID);
    });
    let TaskUUIDsToRemove = this.graphMetaData.TaskUUIDS.filter(TaskUUID => {
      !newTaskUUIDsMetaData.includes(TaskUUID);
    });
    //Do document first as it will reduce the size of the object by DocumentUUIDsToRemove.length when iterating with tasks.
    //Care tasks is 'Dumb' due to only being a list of task UUIDs so will need to check everything until found.
    //When found go to next ->continue
    //If found and deleted, dont increase index
    let documentIndex: number = 0;
    let taskIndex: number;
    for (let GraphDocument of this.GraphData) {
      taskIndex = 0;
      if (DocumentUUIDsToRemove.includes(GraphDocument.DocumentUUID)) {
        this.GraphData.splice(documentIndex, 1);
        continue;
      } else {//Check if any tasks that need removing exist
        for (let Task of GraphDocument.Tasks) {
          if (TaskUUIDsToRemove.includes(Task.TaskUUID)) {
            GraphDocument.Tasks.splice(taskIndex, 1);
            continue;
          }
          taskIndex++;
        }
      }
      documentIndex++;
    }
    this.graphMetaData.DocumentUUIDS = newDocumentUUIDsMetaData;
    this.graphMetaData.TaskUUIDS = newTaskUUIDsMetaData;
  }

  getCurrentTaskUUIDS(): DocumentAndTask[] {
    let requestDocuments: DocumentAndTask[] = new Array<DocumentAndTask>();
    for (let Document of this.GraphData) {
      let documentInfo: DocumentAndTask = new DocumentAndTask();
      let first: boolean = true;
      documentInfo.DocumentUUID = Document.DocumentUUID;
      for (let Task of Document.Tasks) {
        if (first) {
          documentInfo.TaskUUIDs = Task.TaskUUID;
          first = false;
        } else {
          documentInfo.TaskUUIDs += ',' + Task.TaskUUID;
        }
      }
      requestDocuments.push(documentInfo);
    }
    return requestDocuments;
  }

  trimData(startDateCutoff: Date, endDateCutoff: Date) {
    let trimType: TrimType;
    if (startDateCutoff === null) {
      trimType = TrimType.end;
    } else if (endDateCutoff === null) {
      trimType = TrimType.start;
    } else {
      trimType = TrimType.both;
    }
    let newDataToGraph: Array<OrganisedGraphData> = new Array<OrganisedGraphData>();
    let newDocumentInfo: OrganisedGraphData = new OrganisedGraphData();
    for (let Document of this.GraphData) {
      let addDocument: boolean = false;
      for (let DocumentTasks of Document.Tasks) {
        let addTask: boolean = false;
        let newDocumentTask = new OrganisedDocumentTasks();
        let newDocumentTaskData: OrganisedTaskData[];
        for (let Task of DocumentTasks.Data) {
          switch (trimType) {
            case TrimType.both:
              if (Task.Date >= startDateCutoff && Task.Date <= endDateCutoff) {
                addTask = true;
                addDocument = true;
                newDocumentTaskData.push(Task);
              }
              break;
            case TrimType.start:
              if (Task.Date >= startDateCutoff) {
                addTask = true;
                addDocument = true;
                newDocumentTaskData.push(Task);
              }
              break;
            case TrimType.end:
              if (Task.Date <= endDateCutoff) {
                addTask = true;
                addDocument = true;
                newDocumentTaskData.push(Task);
              }
              break;
          }
        }
        if (addTask) {
          newDocumentTask.Data = newDocumentTaskData;
          newDocumentTask.TaskUUID = DocumentTasks.TaskUUID;
          newDocumentTask.TaskName = DocumentTasks.TaskName;
        }
      }
      if (addDocument) {
        newDocumentInfo.DocumentUUID = Document.DocumentUUID;
        newDataToGraph.push(newDocumentInfo);
      }
    }
    this.GraphData = newDataToGraph;
  }

  //This is an expensive call due to object interaction and modification for graphs be careful
  //Is a promise so mutex is used due to multiple calls at the same time.
  HTTPSCallForGraphData(requestData: RequestGraphData) {
    console.log('HTTPSCallForGraphData()');
    this.HTTPSService.GetTaskDataForGraph(requestData).pipe(first())
      .subscribe((serverData: ServerData) => {
        switch (serverData.TypeofRequest) {
          case New:
            console.log('New');
            let newDataToGraph: Array<OrganisedGraphData> = new Array<OrganisedGraphData>();
            let newGraphMetaData: GraphMetaData = new GraphMetaData();
            //Copy all into new data
            for (let taskEntry of serverData.Data) {
              console.log(JSON.stringify(taskEntry));
              //TODO look at moving into new functions. Make this a layer of logic instead of doing
              if (!newGraphMetaData.DocumentUUIDS.includes(taskEntry.DocumentUUID)) {//totally new document
                console.log("New Document Found");
                newGraphMetaData.DocumentUUIDS.push(taskEntry.DocumentUUID);
                newGraphMetaData.TaskUUIDS.push(taskEntry.TaskUUID);
                let newDocumentInformation: OrganisedGraphData = new OrganisedGraphData();
                newDocumentInformation.DocumentUUID = taskEntry.DocumentUUID;
                let newOrganisedDocumentTasks = new OrganisedDocumentTasks();
                newOrganisedDocumentTasks.TaskName = this.getTaskName(taskEntry);
                newOrganisedDocumentTasks.TaskUUID = taskEntry.TaskUUID;
                let newDataEntry = new OrganisedTaskData();
                newDataEntry.Date = this.DateServerToFrontEnd(taskEntry.Date);
                newDataEntry.Value = taskEntry.SubmittedValue;
                newOrganisedDocumentTasks.Data.push(newDataEntry);
                newDocumentInformation.Tasks.push(newOrganisedDocumentTasks);
                newDataToGraph.push(newDocumentInformation);
              } else if (newGraphMetaData.DocumentUUIDS.includes(taskEntry.DocumentUUID) && !newGraphMetaData.TaskUUIDS.includes(taskEntry.TaskUUID)) {
                console.log("New Task Found");
                //new task only.
                newGraphMetaData.TaskUUIDS.push(taskEntry.TaskUUID);
                let newOrganisedDocumentTasks = new OrganisedDocumentTasks();
                newOrganisedDocumentTasks.TaskName = this.getTaskName(taskEntry);
                newOrganisedDocumentTasks.TaskUUID = taskEntry.TaskUUID;
                let newDataEntry = new OrganisedTaskData();
                newDataEntry.Date = this.DateServerToFrontEnd(taskEntry.Date);
                newDataEntry.Value = taskEntry.SubmittedValue;
                newOrganisedDocumentTasks.Data.push(newDataEntry);
                //Get existing document Object and add to it
                for (let document of newDataToGraph) {
                  if (document.DocumentUUID === taskEntry.DocumentUUID) {
                    document.Tasks.push(newOrganisedDocumentTasks);
                    break;
                  }
                }
              }
              else {//Document and Task UUIDS. Will need to add in task data ordered by date
                console.log("Existing Task Found");
                this.addTaskData(taskEntry, newDataToGraph);
                this.checkMetaDataDates(taskEntry, newGraphMetaData);
              }
              console.log(taskEntry.TaskUUID);
            }
            this.GraphData = newDataToGraph;
            this.graphMetaData = newGraphMetaData;
            break;
          case NewTasks://Similar to 'new' except adding straight to current this.dataToGraph
            console.log('NewTasks');
            for (let taskEntry of serverData.Data) {
              //TODO look at moving into new functions. Make this a layer of logic instead of doing
              if (!this.graphMetaData.DocumentUUIDS.includes(taskEntry.DocumentUUID)) {//totally new document
                this.graphMetaData.DocumentUUIDS.push(taskEntry.DocumentUUID);
                this.graphMetaData.TaskUUIDS.push(taskEntry.TaskUUID);
                let newDocumentInformation = new OrganisedGraphData();
                newDocumentInformation.DocumentUUID = taskEntry.DocumentUUID;
                let newOrganisedDocumentTasks = new OrganisedDocumentTasks();
                newOrganisedDocumentTasks.TaskName = this.getTaskName(taskEntry);
                newOrganisedDocumentTasks.TaskUUID = taskEntry.TaskUUID;
                let newDataEntry = new OrganisedTaskData();
                newDataEntry.Date = this.DateServerToFrontEnd(taskEntry.Date);
                newDataEntry.Value = taskEntry.SubmittedValue;
                newOrganisedDocumentTasks.Data.push(newDataEntry);
                newDocumentInformation.Tasks.push(newOrganisedDocumentTasks);
                this.GraphData.push(newDocumentInformation);
              } else if (this.graphMetaData.DocumentUUIDS.includes(taskEntry.DocumentUUID) && !this.graphMetaData.TaskUUIDS.includes(taskEntry.TaskUUID)) {
                //new task only.
                this.graphMetaData.TaskUUIDS.push(taskEntry.TaskUUID);
                let newOrganisedDocumentTasks = new OrganisedDocumentTasks();
                newOrganisedDocumentTasks.TaskName = this.getTaskName(taskEntry);
                newOrganisedDocumentTasks.TaskUUID = taskEntry.TaskUUID;
                let newDataEntry = new OrganisedTaskData();
                newDataEntry.Date = this.DateServerToFrontEnd(taskEntry.Date);
                newDataEntry.Value = taskEntry.SubmittedValue;
                newOrganisedDocumentTasks.Data.push(newDataEntry);
                //Get existing document Object and add to it
                for (let document of this.GraphData) {
                  if (document.DocumentUUID === taskEntry.DocumentUUID) {
                    document.Tasks.push(newOrganisedDocumentTasks);
                    break;
                  }
                }
              }
              else {//Document and Task UUIDS. Will need to add in task data ordered by date
                this.addTaskData(taskEntry, this.GraphData);
                this.checkMetaDataDates(taskEntry, this.graphMetaData);
              }
              console.log(taskEntry.TaskUUID);
            }
            break;
          case NewData://All tasks already exist, so only have to add data to task
            console.log('NewData');
            for (let taskEntry of serverData.Data) {
              this.addTaskData(taskEntry, this.GraphData);
              this.checkMetaDataDates(taskEntry, this.graphMetaData);
              console.log(taskEntry.TaskUUID);
            }
            break;
        }
        console.log("finished HTTPSCallForGraphData() return");
        console.log("Current this.DataToGraph = " + JSON.stringify(this.GraphData));
        //This looks like a race condition, due to using webworkers. BUT each function is atomic so no need for mutex
        if (!--this.numberofCallBacksLeft) {
          this.SetupDataForGraph();
        }
      },
        error => {
          this.errorService.error(error)
        });
  }

  checkMetaDataDates(taskEntry: TaskData, newGraphMetaData: GraphMetaData) {
    let taskEntryDate = this.DateServerToFrontEnd(taskEntry.Date);
    if (newGraphMetaData.EndDateDisplayed < taskEntryDate) {
      this.graphMetaData.EndDateDisplayed = taskEntryDate;
    } else if (newGraphMetaData.StartDateDisplayed > taskEntryDate) {
      this.graphMetaData.StartDateDisplayed = taskEntryDate;
    }
  }

  //Lots of looping due to depth of objects
  addTaskData(taskEntry: TaskData, newDataToGraph: OrganisedGraphData[]) {
    console.log('addTaskData()');

    let taskEntryDate = this.DateServerToFrontEnd(taskEntry.Date);
    for (let Document of newDataToGraph) {
      if (Document.DocumentUUID === taskEntry.DocumentUUID) {
        for (let Task of Document.Tasks) {
          if (Task.TaskUUID === taskEntry.TaskUUID) {
            let index: number = 0;
            //Create new object
            let newDataEntry: OrganisedTaskData = new OrganisedTaskData();
            newDataEntry.Date = taskEntryDate;
            newDataEntry.Value = taskEntry.SubmittedValue;
            for (let DataEntry of Task.Data) {
              if (DataEntry.Date > taskEntryDate) {
                Task.Data.splice(index, 0, newDataEntry);
                return;
              }
              index++;
            }
            //If here need to add into the end
            Task.Data.push(newDataEntry);
          }
        }
      }
    }
  }

  getTaskName(taskEntry: TaskData): string {
    for (let document of this.documents.Documents) {
      if (document.DocumentUUID === taskEntry.DocumentUUID) {
        for (let task of document.Tasks) {
          if (task.UUID === taskEntry.TaskUUID) {
            return task.Name;
          }
        }
      }
    }
    return 'Name Not Found';
  }

  filterTasks(tasksSelected: DocumentAndTask[]): DocumentAndTask[] {
    console.log("*************************filterTasks(tasksSelected: Array<DocumentAndTask>): Array<DocumentAndTask>*************************")
    let newTaskUUIDS: Array<DocumentAndTask> = new Array<DocumentAndTask>();
    for (let DocumentTask of tasksSelected) {
      let DocumentNotFound: boolean = false;
      for (let CurrentDocument of this.GraphData) {
        if (DocumentTask.DocumentUUID === CurrentDocument.DocumentUUID) {//Filter that Document
          console.log("Document Found");
          let newDocumentTask: DocumentAndTask = new DocumentAndTask();
          let selectedUUIDsArray = DocumentTask.TaskUUIDs.split(',');
          let currentUUIDsArray = CurrentDocument.Tasks.map(Task => Task.TaskUUID);
          console.log("currentUUIDsArray: " + currentUUIDsArray.toString() + '|| selectedUUIDsArray: ' + selectedUUIDsArray.toString());
          let filteredUUIDsArray = selectedUUIDsArray.filter(arrayValue => !currentUUIDsArray.includes(arrayValue));
          console.log("filtering Tasks, Found: " + JSON.stringify(filteredUUIDsArray));
          if (filteredUUIDsArray.length) {
            newDocumentTask.DocumentUUID = DocumentTask.DocumentUUID;
            newDocumentTask.TaskUUIDs = filteredUUIDsArray.toString();
            newTaskUUIDS.push(newDocumentTask);
          }
          DocumentNotFound = true;
        }
        if (!DocumentNotFound) {
          newTaskUUIDS.push(DocumentTask);
        }
      }
    }
    return newTaskUUIDS;
  }

  //format of string required to be "2019-07-17 00:00:00" day/month/year
  // from 2019-07-17 00:00:00 to default format
  DateServerToFrontEnd(date: string): Date {
    console.log('DateServerToFrontEnd');
    let newDate = new Date();
    let array: Array<string> = date.split(' ');
    let stringDate: Array<string> = array[0].split('-');
    let stringTime: Array<string> = array[1].split(':');
    newDate.setDate(parseInt(stringDate[2]));
    newDate.setMonth(parseInt(stringDate[1]) - 1);
    newDate.setFullYear(parseInt(stringDate[0]));
    newDate.setHours(parseInt(stringTime[0]));
    newDate.setMinutes(parseInt(stringTime[1]));
    newDate.setSeconds(0, 0);
    return newDate;
  }

  //TODO finish this
  //Note time is ignored and entire day is retrieved
  //Convert to format 'Y-m-d'
  DateConvertFrontEndDateToServer(date: Date): string {
    console.log('DateConvertFrontEndDateToServer -> ' + date.toString())
    return date.toString().replace('\\', '-');
  }
  //Note time is ignored and entire day is retrieved
  //Convert to format from '2019/12/03' to 'Y-m-d'
  StringConvertFrontEndDateToServer(date: string): string {
    console.log('StringConvertFrontEndDateToServer -> ' + date);
    return date.replace('\\', '-');
  }

  ValidDateSelectedForGraph(startDateValue: string, endDateValue: string, allDatesValue: boolean): boolean {
    console.log('*************************ValidDateSelectedForGraph()*************************');
    let startDate = new Date(startDateValue);
    let endDate = new Date(endDateValue);
    if ((startDate instanceof Date && !isNaN(startDate.valueOf()) && startDate instanceof Date && !isNaN(startDate.valueOf())
      && endDate instanceof Date && !isNaN(endDate.valueOf()) && endDate instanceof Date && !isNaN(endDate.valueOf()))
      || allDatesValue) {
      return true;
    } else {
      return false;
    }
  }

  GetAllTasksUUIDSelected(): Array<DocumentAndTask> {
    console.log('*************************GetAllTasksUUIDSelected()*************************');
    let taskSelected = false;
    let selectedTaskUUIDS: Array<DocumentAndTask> = Array<DocumentAndTask>();
    for (let Document of this.documents.Documents) {
      let newDocumentInfo: DocumentAndTask = new DocumentAndTask();
      let first: boolean = true;
      for (let Task of Document.Tasks) {
        if ((<HTMLInputElement> document.getElementById(Task.UUID)).checked) {
          console.log('Found checked: ' + Task.UUID);
          taskSelected = true;
          if (first) {
            newDocumentInfo.TaskUUIDs = Task.UUID
            first = false;
          } else {
            newDocumentInfo.TaskUUIDs += "," + Task.UUID;
          }
        }
      }
      if (taskSelected) {
        console.log("taskSelected=true, DocumentUUID=" + Document.DocumentUUID);
        newDocumentInfo.DocumentUUID = Document.DocumentUUID;
        selectedTaskUUIDS.push(newDocumentInfo);
      }
    }
    if (selectedTaskUUIDS.length) {
      console.log('length = ' + selectedTaskUUIDS.length);
      return selectedTaskUUIDS;
    }
    else {
      console.log('length = 0');
      return null;
    }
  }





  SetupDataForGraph() {
    console.log('SetupDataForGraph()');
    /**
  * Warning this section will be intensive so only called once per new set of data
  */
    /**
      * this.lineChartData = [
      * { data: [65, 59, 80, 81, 56, 55, 40], label: 'Series A' },
      * { data: [28, 48, 40, 19, 86, 27, 90], label: 'Series B' },
      * { data: [180, 480, 770, 90, 1000, 270, 400], label: 'Series C', yAxisID: 'y-axis-1' }
      * ];
      */
    this.lineChartData = new Array<ChartDataSets>();
    for (let Document of this.GraphData) {
      for (let Task of Document.Tasks) {
        //Add points to dataset
        let chartPoints: Array<ChartPoint> = Array<ChartPoint>();
        for (let dataEntry of Task.Data) {
          chartPoints.push({ x: dataEntry.Date, y: dataEntry.Value, });
        }
        let dataset: ChartDataSets = {
          data: chartPoints,
          label: Task.TaskName,
        };
        this.lineChartData.push(dataset);
        console.log(this.lineChartData.length);
        console.log(JSON.stringify(this.lineChartData));
      }
    }
    this.chart.update();
  }

}